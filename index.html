<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable Helicopter Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #1a2980, #26d0ce);
            color: white;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        #title {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 22px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        .hut-info {
            font-size: 14px;
            margin-top: 10px;
            line-height: 1.5;
            color: #aaffaa;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #info-panel h2 {
            margin-top: 0;
            color: #4fc3f7;
            text-align: center;
            border-bottom: 1px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 10px;
        }
        .control-group {
            margin: 15px 0;
        }
        .control-label {
            display: inline-block;
            width: 140px;
            color: #bbbbff;
        }
        .control-value {
            color: #4fc3f7;
            font-weight: bold;
        }
        #debug-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
            transition: all 0.3s ease;
        }
        #debug-toggle:hover {
            background: rgba(30, 30, 60, 0.8);
            transform: scale(1.05);
        }
        #scoreboard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 18px;
            pointer-events: none;
            z-index: 14;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #timer {
            position: absolute;
            top: 60px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 18px;
            pointer-events: none;
            z-index: 14;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #result-overlay {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.35);
            z-index: 50;
            pointer-events: auto;
        }
        #result-panel {
            background: rgba(0, 0, 0, 0.85);
            padding: 22px 28px;
            border-radius: 14px;
            text-align: center;
            min-width: 260px;
            max-width: 90vw;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        .result-title { font-size: 22px; margin-bottom: 8px; }
        .result-desc { font-size: 16px; color: #cfd8dc; }
        #collision-log {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 15px;
            max-height: 200px;
            overflow-y: auto;
            width: 300px;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #collision-log h3 {
            margin-top: 0;
            color: #4fc3f7;
            border-bottom: 1px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 8px;
        }
        .log-entry {
            margin: 8px 0;
            padding: 5px;
            border-radius: 4px;
            background: rgba(50, 50, 80, 0.4);
        }
        .warning {
            color: #ff9800;
        }
        .danger {
            color: #f44336;
            font-weight: bold;
        }
        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            width: 200px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #speed-value {
            font-size: 32px;
            font-weight: bold;
            color: #4fc3f7;
            margin: 10px 0;
        }
        #altitude-value {
            font-size: 24px;
            color: #a5d6a7;
            margin: 5px 0;
        }
        #status {
            font-size: 18px;
            margin-top: 10px;
            color: #c5e1a5;
        }
        canvas {
            display: block;
        }
        /* Toolbar */
        #toolbar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 12px;
            border-radius: 12px;
            display: flex;
            gap: 8px;
            pointer-events: auto;
            z-index: 15;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #powerup-banner {
            position: absolute;
            top: 72px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 16px;
            color: #fff;
            pointer-events: none;
            z-index: 16;
            box-shadow: 0 0 15px rgba(150, 100, 255, 0.5);
            border: 1px solid rgba(170, 140, 255, 0.35);
            display: none;
        }
        .tool-btn {
            background: rgba(30, 30, 60, 0.8);
            color: #fff;
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        .tool-btn.active {
            background: rgba(0, 120, 200, 0.8);
        }
        /* Mobile controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 12px;
            right: 12px;
            display: none;
            justify-content: space-between;
            gap: 12px;
            padding: 0;
            pointer-events: auto;
            z-index: 30;
            box-sizing: border-box;
        }
        .pad {
            width: 160px;
            height: 160px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
        }
        .pad-btn {
            background: rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            color: #ffffff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 12px rgba(0, 150, 255, 0.35);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .pad-btn:active {
            background: rgba(30, 30, 60, 0.8);
            transform: scale(0.98);
        }

        /* Responsive UI tweaks */
        @media (max-width: 900px) {
            #title { font-size: 18px; padding: 10px 16px; right: 12px; top: 12px; }
            #info-panel { max-width: 260px; padding: 14px; left: 12px; top: 64px; }
            #speedometer { width: 160px; padding: 14px; right: 12px; bottom: 12px; }
            #debug-toggle { left: 12px; bottom: 12px; padding: 10px 14px; }
            #collision-log { width: 240px; left: 12px; bottom: 70px; }
            #mobile-controls { display: flex; }
            .pad { width: min(33vw, 150px); height: min(33vw, 150px); }
            .pad-btn { font-size: 16px; }
            #toolbar { top: 12px; }
            /* Hide debug toggle on phone-sized screens */
            #debug-toggle { display: none; }
        }
        @media (max-width: 420px) {
            .pad { width: min(40vw, 140px); height: min(40vw, 140px); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui-container">
            <div id="scoreboard">Score: <span id="score-value">0</span></div>

            <div id="toolbar">
                <button class="tool-btn active" id="toggle-info">Info</button>
                <button class="tool-btn active" id="toggle-speed">Speedo</button>
                <button class="tool-btn active" id="toggle-log">Log</button>
            </div>

            <div id="powerup-banner"></div>

            <div id="info-panel">
                <h2>Flight Controls</h2>
                <div class="control-group">
                    <span class="control-label">W / S:</span>
                    <span class="control-value">Forward / Backward</span>
                </div>
                <div class="control-group">
                    <span class="control-label">Arrow Keys:</span>
                    <span class="control-value">Up/Down/Left/Right</span>
                </div>
                <div class="control-group">
                    <span class="control-label">A / D:</span>
                    <span class="control-value">Rotate Left/Right</span>
                </div>
                <div class="control-group">
                    <span class="control-label">R:</span>
                    <span class="control-value">Reset Helicopter</span>
                </div>
                <div class="control-group">
                    <span class="control-label">Current Speed:</span>
                    <span id="current-speed" class="control-value">0 m/s</span>
                </div>
                <div class="control-group">
                    <span class="control-label">Current Altitude:</span>
                    <span id="current-altitude" class="control-value">0 m</span>
                </div>
            </div>

            <div id="debug-toggle" onclick="toggleDebug()">TOGGLE DEBUG VIEW</div>

            <div id="speedometer">
                <div>SPEED</div>
                <div id="speed-value">0.00</div>
                <div>m/s</div>
                <div id="altitude-value">ALT: 0m</div>
                <div id="status">Status: Flying</div>
            </div>

            <div id="collision-log">
                <h3>Collision Log</h3>
                <div id="collision-entries"></div>
            </div>

            <div id="timer">03:00</div>

            <div id="result-overlay">
                <div id="result-panel">
                    <div id="result-title" class="result-title">Result</div>
                    <div id="result-desc" class="result-desc"></div>
                </div>
            </div>

            <!-- Mobile controls (shown on small screens) -->
            <div id="mobile-controls" aria-label="On-screen controls">
                <div class="pad" id="pad-left">
                    <div></div><button class="pad-btn" id="btn-l-up">↑</button><div></div>
                    <button class="pad-btn" id="btn-l-left">←</button><div></div><button class="pad-btn" id="btn-l-right">→</button>
                    <div></div><button class="pad-btn" id="btn-l-down">↓</button><div></div>
                </div>
                <div class="pad" id="pad-right">
                    <div></div><button class="pad-btn" id="btn-r-up">FWD</button><div></div>
                    <button class="pad-btn" id="btn-r-left">⟲</button><div></div><button class="pad-btn" id="btn-r-right">⟳</button>
                    <div></div><button class="pad-btn" id="btn-r-down">BACK</button><div></div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // Initialize Three.js and Cannon.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 30, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Initialize physics world
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(100, 150, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Create skybox
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Create sun
        const sunGeometry = new THREE.SphereGeometry(15, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(150, 200, -100);
        scene.add(sun);

        // Terrain generation
        const terrainSize = 600;
        const terrainResolution = 80;
        // Mountain peaks (x,z positions relative to world), amplitude and radius
        const mountainPeaks = [
            // Sharper, taller peaks with smaller radii so they stand out
            { x: 140, z: -100, amplitude: 55, radius: 35 },
            { x: -160, z: 150, amplitude: 48, radius: 30 },
            { x: 10, z: -190, amplitude: 45, radius: 28 },
            { x: 200, z: 40, amplitude: 52, radius: 34 }
        ];
        const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainResolution - 1, terrainResolution - 1);

        // Height function for terrain
        function terrainHeight(x, y) {
            const scale = 0.03;
            let h = (
                Math.sin(x * scale) * Math.cos(y * scale) * 12 +
                Math.sin(x * scale * 3) * Math.cos(y * scale * 3) * 4 +
                Math.sin(x * scale * 6) * Math.cos(y * scale * 6) * 1.5
            );
            // Add mountain contributions (Gaussian bumps)
            for (let i = 0; i < mountainPeaks.length; i++) {
                const p = mountainPeaks[i];
                const dx = x - p.x;
                const dz = y - p.z;
                const r2 = dx * dx + dz * dz;
                const sigma2 = p.radius * p.radius;
                h += p.amplitude * Math.exp(-r2 / (2 * sigma2));
            }
            return h;
        }

        // Apply terrain height and vertex colors (snowy peaks)
        const vertices = terrainGeometry.attributes.position.array;
        const colors = [];
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const y = vertices[i + 1];
            const h = terrainHeight(x, y);
            vertices[i + 2] = h;
            // Color by altitude
            const snow = 38; // higher snow line so only peaks are white
            const rock = 20; // rock band
            let r, g, b;
            if (h >= snow) { r = 1.0; g = 1.0; b = 1.0; } // white snow
            else if (h >= rock) { r = 0.6; g = 0.6; b = 0.6; } // gray rock
            else { r = 0.20; g = 0.70; b = 0.20; } // green grass
            colors.push(r, g, b);
        }
        terrainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        terrainGeometry.attributes.position.needsUpdate = true;
        terrainGeometry.computeVertexNormals();

        // Create height lookup from the actual terrain mesh vertices
        function getTerrainHeightFromMesh(worldX, worldZ) {
            // Convert world coordinates to terrain grid coordinates
            const gridX = (worldX / terrainSize + 0.5) * (terrainResolution - 1);
            const gridZ = (worldZ / terrainSize + 0.5) * (terrainResolution - 1);
            
            // Clamp to valid range
            const x = Math.max(0, Math.min(terrainResolution - 1, gridX));
            const z = Math.max(0, Math.min(terrainResolution - 1, gridZ));
            
            // Get the four surrounding vertices
            const x0 = Math.floor(x);
            const z0 = Math.floor(z);
            const x1 = Math.min(x0 + 1, terrainResolution - 1);
            const z1 = Math.min(z0 + 1, terrainResolution - 1);
            
            // Get heights from vertex array (every 3rd element is height)
            const h00 = vertices[(z0 * terrainResolution + x0) * 3 + 2];
            const h10 = vertices[(z0 * terrainResolution + x1) * 3 + 2];
            const h01 = vertices[(z1 * terrainResolution + x0) * 3 + 2];
            const h11 = vertices[(z1 * terrainResolution + x1) * 3 + 2];
            
            // Bilinear interpolation
            const fx = x - x0;
            const fz = z - z0;
            const h0 = h00 * (1 - fx) + h10 * fx;
            const h1 = h01 * (1 - fx) + h11 * fx;
            return h0 * (1 - fz) + h1 * fz;
        }

        const terrainMaterial = new THREE.MeshLambertMaterial({
            vertexColors: true,
            side: THREE.DoubleSide
        });

        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.receiveShadow = true;
        terrain.position.y = -2;
        scene.add(terrain);

        // Precise ground sampling using raycasting against the terrain mesh
        const _raycaster = new THREE.Raycaster();
        const _down = new THREE.Vector3(0, -1, 0);
        function groundYAt(x, z) {
            // Use the exact same vertex data that renders the terrain
            return getTerrainHeightFromMesh(x, z) + terrain.position.y;
        }
        function groundYFormula(x, z) { 
            return getTerrainHeightFromMesh(x, z) + terrain.position.y; 
        }

        // Add physics terrain
        const heightfieldData = [];
        for (let i = 0; i < terrainResolution; i++) {
            heightfieldData.push([]);
            for (let j = 0; j < terrainResolution; j++) {
                const x = (j / (terrainResolution - 1) - 0.5) * terrainSize;
                const y = (i / (terrainResolution - 1) - 0.5) * terrainSize;
                heightfieldData[i].push(terrainHeight(x, y) + terrain.position.y);
            }
        }

        const terrainShape = new CANNON.Heightfield(heightfieldData, {
            elementSize: terrainSize / (terrainResolution - 1)
        });

        const terrainBody = new CANNON.Body({ mass: 0 });
        terrainBody.addShape(terrainShape);
        // Align physics heightfield world transform with visual terrain transform
        terrainBody.position.set(-terrainSize/2, terrain.position.y, terrainSize/2);
        terrainBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
        world.addBody(terrainBody);

        // Create a single large water plane
        const waterGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize);
        const waterMaterial = new THREE.MeshLambertMaterial({
            color: 0x1E90FF,
            transparent: true,
            opacity: 0.7
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -2.5; // Adjusted water level
        scene.add(water);

        // Create trees
        const trees = [];
        const treeCount = 1600;
        const treeMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });

        for (let i = 0; i < treeCount; i++) {
            const x = (Math.random() - 0.5) * terrainSize * 0.8;
            const z = (Math.random() - 0.5) * terrainSize * 0.8;
            const height = groundYFormula(x, z);
            const groundY = groundYAt(x, z);

            if (groundY > water.position.y + 1) {
                // Thin out trees with altitude and keep peaks bare
                const snowLine = 38;
                const rockLine = 20;
                if (height >= snowLine - 2) continue;
                const altitudeFactor = Math.max(0, 1 - Math.max(0, (height - rockLine)) / (snowLine - rockLine));
                if (Math.random() > altitudeFactor) continue;
                const treeHeight = Math.random() * 8 + 6;
                const treeRadius = treeHeight / 5;

                const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 2, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                const baseY = groundYAt(x, z);
                trunk.position.set(x, baseY + 1.0, z);
                trunk.castShadow = true;
                scene.add(trunk);

                // Disable spherical-cluster canopy variant (always use cone)
                const useClusterCanopy = false;
                if (useClusterCanopy) {
                    const canopyGroup = new THREE.Group();
                    const leafColors = [
                        0x2e7d32, 0x388e3c, 0x43a047, 0x4caf50,
                        0x66bb6a, 0x1b5e20, 0x2e8b57
                    ];
                    const sphereCount = Math.floor(Math.random() * 5) + 6; // 6 - 10
                    const canopySpread = treeRadius * 0.9;
                    for (let j = 0; j < sphereCount; j++) {
                        const radius = Math.random() * (treeRadius * 0.35) + (treeRadius * 0.25);
                        const geo = new THREE.SphereGeometry(radius, 10, 10);
                        const color = leafColors[Math.floor(Math.random() * leafColors.length)];
                        const mat = new THREE.MeshLambertMaterial({ color });
                        const s = new THREE.Mesh(geo, mat);
                        const offsetX = (Math.random() - 0.5) * canopySpread;
                        const offsetZ = (Math.random() - 0.5) * canopySpread;
                        const offsetY = Math.random() * (treeHeight * 0.6);
                        s.position.set(offsetX, offsetY, offsetZ);
                        s.castShadow = true;
                        canopyGroup.add(s);
                    }
                    canopyGroup.position.set(x, baseY + 2 + treeHeight * 0.35, z);
                    scene.add(canopyGroup);
                    trees.push({ trunk, canopy: canopyGroup, position: new THREE.Vector3(x, height, z) });
                } else {
                const canopyGeometry = new THREE.ConeGeometry(treeRadius, treeHeight, 8);
                const canopy = new THREE.Mesh(canopyGeometry, treeMaterial);
                    canopy.position.set(x, baseY + 2 + treeHeight/2, z);
                canopy.castShadow = true;
                scene.add(canopy);
                trees.push({ trunk, canopy, position: new THREE.Vector3(x, height, z) });
                }
            }
        }

        // Create bushes
        const bushes = [];
        const bushCount = 1800;
        const bushColors = [0x32CD32, 0x228B22, 0x3CB371, 0x2E8B57, 0x008000];

        for (let i = 0; i < bushCount; i++) {
            const x = (Math.random() - 0.5) * terrainSize * 0.8;
            const z = (Math.random() - 0.5) * terrainSize * 0.8;
            const height = groundYFormula(x, z);
            const groundY = groundYAt(x, z);

            if (groundY > water.position.y + 1.5) {
                // Fade out bushes above rock band
                const rockLine = 20;
                if (height > rockLine + 5) continue;
                const bushGroup = new THREE.Group();
                const bushSize = Math.random() * 4 + 3;

                const sphereCount = Math.floor(Math.random() * 4) + 3;
                for (let j = 0; j < sphereCount; j++) {
                    const radius = Math.random() * 0.8 + 0.6;
                    const color = bushColors[Math.floor(Math.random() * bushColors.length)];
                    const sphereGeometry = new THREE.SphereGeometry(radius, 8, 8);
                    const sphereMaterial = new THREE.MeshLambertMaterial({ color });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

                    const offsetX = (Math.random() - 0.5) * bushSize;
                    const offsetZ = (Math.random() - 0.5) * bushSize;
                    const offsetY = Math.random() * 1.5;

                    sphere.position.set(offsetX, offsetY, offsetZ);
                    sphere.castShadow = true;
                    bushGroup.add(sphere);
                }

                // Position the bush group at min ground height over its footprint
                const groundBase = groundYAt(x, z);
                bushGroup.position.set(x, groundBase, z);
                scene.add(bushGroup);
                bushes.push(bushGroup);
            }
        }

        // Create wooden huts with improved placement
        const huts = [];
        const hutPositions = [
            {x: 40, z: 30}, {x: -35, z: 45}, {x: 25, z: -50},
            {x: -50, z: -25}, {x: 60, z: -30}, {x: -20, z: 70},
            {x: 45, z: 55}, {x: -70, z: 20}, {x: 10, z: -60},
            {x: -30, z: 20}, {x: 20, z: 40}, {x: -40, z: -40}
        ];

        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.lineWidth = 2;

            for (let i = 0; i < 80; i++) {
                const x1 = Math.random() * canvas.width;
                const y1 = Math.random() * canvas.height;
                const x2 = x1 + (Math.random() - 0.5) * 80;
                const y2 = y1 + (Math.random() - 0.5) * 80;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.bezierCurveTo(
                    x1 + (Math.random() - 0.5) * 60, y1 + (Math.random() - 0.5) * 60,
                    x2 + (Math.random() - 0.5) * 60, y2 + (Math.random() - 0.5) * 60,
                    x2, y2
                );
                ctx.stroke();
            }
            return canvas;
        }

        const woodTexture = new THREE.CanvasTexture(createWoodTexture());
        const darkWoodTexture = new THREE.CanvasTexture(createWoodTexture());

        hutPositions.forEach(pos => {
            // Calculate average height for the hut footprint
            let heightSum = 0;
            let samplePoints = 0;
            
            // Sample multiple points within the hut area
            for (let dx = -1; dx <= 1; dx += 1) {
                for (let dz = -1; dz <= 1; dz += 1) {
                    const sampleX = pos.x + dx * 3;
                    const sampleZ = pos.z + dz * 3;
                    heightSum += terrainHeight(sampleX, sampleZ);
                    samplePoints++;
                }
            }
            
            const avgHeight = heightSum / samplePoints;

            if (avgHeight > water.position.y + 2) {
                const hutWidth = 6 + Math.random() * 4;
                const hutHeight = 4 + Math.random() * 2;
                const hutDepth = 6 + Math.random() * 4;

                const hutGeometry = new THREE.BoxGeometry(hutWidth, hutHeight, hutDepth);
                const hutMaterial = new THREE.MeshLambertMaterial({ map: woodTexture });
                const hut = new THREE.Mesh(hutGeometry, hutMaterial);
                hut.position.set(pos.x, avgHeight, pos.z);
                hut.castShadow = true;
                scene.add(hut);

                const roofHeight = hutHeight * 1;
                const roofGeometry = new THREE.ConeGeometry(hutWidth, roofHeight, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ map: darkWoodTexture });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(pos.x, avgHeight + hutHeight, pos.z);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                scene.add(roof);

                const doorWidth = hutWidth * 0.3;
                const doorHeight = hutHeight * 0.7;
                const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.15);
                const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x5D2906 });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(pos.x, avgHeight, pos.z + hutDepth/2 + 0.05);
                scene.add(door);

                const windowSize = Math.min(hutWidth, hutHeight) * 0.25;
                const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.15);
                const windowMaterial = new THREE.MeshLambertMaterial({
                    color: 0xADD8E6,
                    transparent: true,
                    opacity: 0.6
                });
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(
                    pos.x - hutWidth/4,
                    avgHeight,
                    pos.z + hutDepth/2 + 0.05
                );
                scene.add(window);

                huts.push({ hut, roof, door, window, position: new THREE.Vector3(pos.x, avgHeight, pos.z) });
            }
        });

        // Create helicopter
        const helicopter = new THREE.Group();

        const bodyGeometry = new THREE.CylinderGeometry(1.2, 1.2, 5, 16);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0x4169E1,
            shininess: 80
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.z = Math.PI / 2;
        body.castShadow = true;
        helicopter.add(body);

        const tailGeometry = new THREE.CylinderGeometry(0.25, 0.4, 4, 10);
        const tailMaterial = new THREE.MeshPhongMaterial({
            color: 0x5577EE,
            shininess: 60
        });
        const tail = new THREE.Mesh(tailGeometry, tailMaterial);
        tail.position.set(-3.5, 0.4, 0);
        tail.rotation.z = Math.PI / 2;
        tail.castShadow = true;
        helicopter.add(tail);

        // Translucent rotor disks
        const mainRotor = new THREE.Mesh(
            new THREE.CircleGeometry(5.5, 48),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.22, side: THREE.DoubleSide })
        );
        mainRotor.rotation.x = -Math.PI / 2; // horizontal (XZ plane)
        mainRotor.position.set(0, 2.5, 0);
        helicopter.add(mainRotor);

        const tailRotor = new THREE.Mesh(
            new THREE.CircleGeometry(2.2, 40),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.22, side: THREE.DoubleSide })
        );
        tailRotor.position.set(-5, 0.4, 0);
        // Make disk face sideways: plane = YZ, so normal = ±X
        tailRotor.rotation.set(0, -Math.PI / 2, 0);
        helicopter.add(tailRotor);

        const skidGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4, 8);
        const skidMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });

        const leftSkid = new THREE.Mesh(skidGeometry, skidMaterial);
        leftSkid.position.set(0, -1.5, -1.5);
        helicopter.add(leftSkid);

        const rightSkid = new THREE.Mesh(skidGeometry, skidMaterial);
        rightSkid.position.set(0, -1.5, 1.5);
        helicopter.add(rightSkid);

        const frontSkidGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
        const frontSkid = new THREE.Mesh(frontSkidGeometry, skidMaterial);
        frontSkid.position.set(1.5, -1.5, 0);
        frontSkid.rotation.z = Math.PI / 2;
        helicopter.add(frontSkid);

        const backSkid = new THREE.Mesh(frontSkidGeometry, skidMaterial);
        backSkid.position.set(-1.5, -1.5, 0);
        backSkid.rotation.z = Math.PI / 2;
        helicopter.add(backSkid);

        helicopter.position.set(0, 30, 0);
        scene.add(helicopter);

        // Create helipads with red crosses
        const helipads = [];
        const helipadCount = 5;
        const helipadColors = [0x4fc3f7, 0xffcc80, 0xa5d6a7, 0xffab91, 0xce93d8];
        for (let i = 0; i < helipadCount; i++) {
            let x, z, y;
            let tries = 0;
            do {
                x = (Math.random() - 0.5) * terrainSize * 0.7;
                z = (Math.random() - 0.5) * terrainSize * 0.7;
                y = groundYFormula(x, z);
                tries++;
            } while ((y <= water.position.y + 2) && tries < 50);

            const padRadius = 4;
            const padHeight = 0.2;
            const pad = new THREE.Mesh(
                new THREE.CylinderGeometry(padRadius, padRadius, padHeight, 32),
                new THREE.MeshLambertMaterial({ color: helipadColors[i % helipadColors.length] })
            );
            pad.receiveShadow = true;
            pad.position.set(x, y - padHeight/2, z);
            scene.add(pad);

            const crossThickness = 0.4;
            const crossLength = padRadius * 1.8;
            const crossMat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
            const cross1 = new THREE.Mesh(new THREE.BoxGeometry(crossLength, crossThickness, crossThickness), crossMat);
            const cross2 = new THREE.Mesh(new THREE.BoxGeometry(crossThickness, crossThickness, crossLength), crossMat);
            cross1.position.set(x, y + crossThickness/2 + 0.02, z);
            cross2.position.set(x, y + crossThickness/2 + 0.02, z);
            cross1.castShadow = true; cross2.castShadow = true;
            scene.add(cross1); scene.add(cross2);

            helipads.push({ position: new THREE.Vector3(x, y, z), radius: padRadius, scored: false, pad, cross1, cross2 });
        }

        // Create colored hoops to fly through
        const hoops = [];
        const hoopCount = 8;
        const hoopColors = [0xff7043, 0x42a5f5, 0x66bb6a, 0xffca28, 0xab47bc, 0x26a69a, 0xef5350, 0x8d6e63];
        for (let i = 0; i < hoopCount; i++) {
            const ringRadius = 3.5; // major radius
            const tubeRadius = 0.35; // thickness of ring
            const torus = new THREE.Mesh(
                new THREE.TorusGeometry(ringRadius, tubeRadius, 12, 48),
                new THREE.MeshLambertMaterial({ color: hoopColors[i % hoopColors.length] })
            );

            const hx = (Math.random() - 0.5) * terrainSize * 0.6;
            const hz = (Math.random() - 0.5) * terrainSize * 0.6;
            const hy = Math.max(groundYFormula(hx, hz) + 4, water.position.y + 4) + Math.random() * 16;

            torus.position.set(hx, hy, hz);
            torus.rotation.y = Math.random() * Math.PI * 2; // face random direction
            torus.castShadow = true;
            scene.add(torus);

            hoops.push({ mesh: torus, position: new THREE.Vector3(hx, hy, hz), centerRadius: ringRadius, scored: false });
        }

        // Add physics body for helicopter
        const helicopterShape = new CANNON.Box(new CANNON.Vec3(2, 1.2, 1));
        const helicopterBody = new CANNON.Body({
            mass: 5,
            linearDamping: 0.5,
            angularDamping: 0.8
        });
        helicopterBody.addShape(helicopterShape);
        helicopterBody.position.copy(helicopter.position);
        world.addBody(helicopterBody);

        // Add clouds
        const clouds = [];
        const cloudGeometry = new THREE.SphereGeometry(16, 24, 24);
        const cloudMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.5,
            shininess: 10
        });

        for (let i = 0; i < 20; i++) {
            const cloudGroup = new THREE.Group();
            const cloudCount = Math.floor(Math.random() * 4) + 3;

            for (let j = 0; j < cloudCount; j++) {
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                
                cloud.position.set(
                    (Math.random() - 0.5) * 24,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 24
                );
                cloud.scale.set(
                    Math.random() + 1,
                    Math.random() * 0.5 + 0.5,
                    Math.random() + 1
                );
                cloudGroup.add(cloud);
            }

            cloudGroup.position.set(
                (Math.random() - 0.5) * 800,
                100 + Math.random() * 100,
                (Math.random() - 0.5) * 800
            );
            scene.add(cloudGroup);
            clouds.push(cloudGroup);
        }

        // Speed boost orbs (glowing yellow spheres)
        const boostOrbs = [];
        const boostOrbCount = 12;
        for (let i = 0; i < boostOrbCount; i++) {
            const group = new THREE.Group();
            const inner = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 16, 16),
                new THREE.MeshPhongMaterial({ color: 0xffeb3b, emissive: 0xffd54f, emissiveIntensity: 1.0, shininess: 100 })
            );
            const outer = new THREE.Mesh(
                new THREE.SphereGeometry(1.3, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.35 })
            );
            const light = new THREE.PointLight(0xffee58, 0.8, 20);
            group.add(inner);
            group.add(outer);
            group.add(light);

            const x = (Math.random() - 0.5) * terrainSize * 0.6;
            const z = (Math.random() - 0.5) * terrainSize * 0.6;
            const ground = groundYFormula(x, z);
            const baseY = Math.max(ground + 6, water.position.y + 6) + Math.random() * 12;
            group.position.set(x, baseY, z);
            scene.add(group);
            boostOrbs.push({ group, baseY, phase: Math.random() * Math.PI * 2, collected: false });
        }

        // Shield orbs (glowing purple spheres) – grant temporary invulnerability
        const shieldOrbs = [];
        const shieldOrbCount = 8;
        for (let i = 0; i < shieldOrbCount; i++) {
            const group = new THREE.Group();
            const inner = new THREE.Mesh(
                new THREE.SphereGeometry(0.9, 16, 16),
                new THREE.MeshPhongMaterial({ color: 0xaa66ff, emissive: 0x8844ff, emissiveIntensity: 1.0, shininess: 100 })
            );
            const outer = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xcc99ff, transparent: true, opacity: 0.35 })
            );
            const light = new THREE.PointLight(0xbb88ff, 0.8, 20);
            group.add(inner);
            group.add(outer);
            group.add(light);

            const x = (Math.random() - 0.5) * terrainSize * 0.6;
            const z = (Math.random() - 0.5) * terrainSize * 0.6;
            const ground = groundYFormula(x, z);
            const baseY = Math.max(ground + 7, water.position.y + 7) + Math.random() * 14;
            group.position.set(x, baseY, z);
            scene.add(group);
            shieldOrbs.push({ group, baseY, phase: Math.random() * Math.PI * 2, collected: false });
        }

        // Birds
        const birds = [];
        const birdCount = 20;
        const birdBodyGeometry = new THREE.ConeGeometry(0.7, 1.6, 10);
        const birdMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
        // Wing geometries with hinge at inner edge
        const wingWidth = 1.6, wingThickness = 0.08, wingDepth = 0.4;
        const wingGeomL = new THREE.BoxGeometry(wingWidth, wingThickness, wingDepth);
        wingGeomL.translate(wingWidth/2, 0, 0);
        const wingGeomR = new THREE.BoxGeometry(wingWidth, wingThickness, wingDepth);
        wingGeomR.translate(-wingWidth/2, 0, 0);
        function spawnBird() {
            const x = (Math.random() - 0.5) * terrainSize * 0.6;
            const z = (Math.random() - 0.5) * terrainSize * 0.6;
            const ground = terrainHeight(x, z);
            const y = Math.max(ground + 8, water.position.y + 8) + Math.random() * 20;

            const group = new THREE.Group();
            const body = new THREE.Mesh(birdBodyGeometry, birdMaterial);
            body.castShadow = true;
            body.rotation.z = Math.PI; // point forward
            group.add(body);

            const wingL = new THREE.Mesh(wingGeomL, birdMaterial);
            const wingR = new THREE.Mesh(wingGeomR, birdMaterial);
            wingL.castShadow = true; wingR.castShadow = true;
            group.add(wingL); group.add(wingR);

            group.position.set(x, y, z);
            scene.add(group);
            birds.push({
                group,
                wingL,
                wingR,
                velocity: new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*0.3, (Math.random()-0.5)*2),
                wanderPhase: Math.random() * Math.PI * 2,
                wingPhase: Math.random() * Math.PI * 2,
                wingSpeed: 8 + Math.random() * 6,
                chasing: false
            });
        }
        for (let i = 0; i < birdCount; i++) spawnBird();

        // Flight controls
        const keys = { w: false, s: false, a: false, d: false, up: false, down: false, left: false, right: false };
        document.addEventListener('keydown', (event) => {
            switch(event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyD': keys.d = true; break;
                case 'ArrowUp': keys.up = true; break;
                case 'ArrowDown': keys.down = true; break;
                case 'ArrowLeft': keys.left = true; break;
                case 'ArrowRight': keys.right = true; break;
                case 'KeyR': resetHelicopter(); break;
            }
        });
        document.addEventListener('keyup', (event) => {
            switch(event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyD': keys.d = false; break;
                case 'ArrowUp': keys.up = false; break;
                case 'ArrowDown': keys.down = false; break;
                case 'ArrowLeft': keys.left = false; break;
                case 'ArrowRight': keys.right = false; break;
            }
        });

        // Mobile/touch controls
        // Detect small screens for mobile control enablement
        function isSmallScreen() { return Math.min(window.innerWidth, window.innerHeight) <= 900; }

        function bindButtonToKey(buttonId, keyName) {
            const el = document.getElementById(buttonId);
            if (!el) return;

            const press = (e) => { e.preventDefault(); keys[keyName] = true; };
            const release = (e) => { e.preventDefault(); keys[keyName] = false; };

            el.addEventListener('pointerdown', press);
            el.addEventListener('pointerup', release);
            el.addEventListener('pointerleave', release);
            el.addEventListener('pointercancel', release);
            el.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        let mobileControlsInitialized = false;

        function setupMobileControls() {
            const controls = document.getElementById('mobile-controls');
            if (!controls) return;
            if (mobileControlsInitialized) return;

            // Left pad: Arrow keys (strafe and altitude)
            bindButtonToKey('btn-l-up', 'up');
            bindButtonToKey('btn-l-down', 'down');
            bindButtonToKey('btn-l-left', 'left');
            bindButtonToKey('btn-l-right', 'right');

            // Right pad: Forward/Back and Yaw
            bindButtonToKey('btn-r-up', 'w');
            bindButtonToKey('btn-r-down', 's');
            bindButtonToKey('btn-r-left', 'a');
            bindButtonToKey('btn-r-right', 'd');

            // Ensure the controls container always fits horizontally
            const container = document.getElementById('mobile-controls');
            if (container) {
                container.style.maxWidth = '100%';
            }

            mobileControlsInitialized = true;
        }

        if (isSmallScreen()) { setupMobileControls(); }

        // Panel toggles
        function setupPanelToggles() {
            const infoPanel = document.getElementById('info-panel');
            const speedometer = document.getElementById('speedometer');
            const collisionLogPanel = document.getElementById('collision-log');
            const btnInfo = document.getElementById('toggle-info');
            const btnSpeed = document.getElementById('toggle-speed');
            const btnLog = document.getElementById('toggle-log');

            function toggle(el, btn) {
                if (!el) return;
                const nowVisible = el.style.display !== 'none';
                el.style.display = nowVisible ? 'none' : '';
                btn.classList.toggle('active', !nowVisible);
            }

            btnInfo.addEventListener('click', () => toggle(infoPanel, btnInfo));
            btnSpeed.addEventListener('click', () => toggle(speedometer, btnSpeed));
            btnLog.addEventListener('click', () => toggle(collisionLogPanel, btnLog));

            // Hide all panels by default
            if (infoPanel) infoPanel.style.display = 'none';
                btnInfo.classList.remove('active');
                if (collisionLogPanel) collisionLogPanel.style.display = 'none';
                btnLog.classList.remove('active');
            if (speedometer) speedometer.style.display = 'none';
            btnSpeed.classList.remove('active');
        }
        setupPanelToggles();

        // Debug mode toggle
        let debugMode = false;
        const debugObjects = [];

        function toggleDebug() {
            debugMode = !debugMode;
            debugObjects.forEach(obj => { obj.visible = debugMode; });
            document.getElementById('debug-toggle').textContent = debugMode ?
                'DEBUG VIEW: ON' : 'DEBUG VIEW: OFF';
            document.getElementById('debug-toggle').style.background = debugMode ?
                'rgba(200, 50, 50, 0.8)' : 'rgba(0, 0, 0, 0.7)';
        }

        // Add debug objects for huts
        hutPositions.forEach(pos => {
            const height = terrainHeight(pos.x, pos.z);
            if (height > water.position.y + 1) {
                const debugBox = new THREE.BoxHelper(new THREE.Mesh(
                    new THREE.BoxGeometry(6, 4, 6)
                ), 0xffff00);
                debugBox.position.set(pos.x, height + 2, pos.z);
                debugBox.visible = false;
                scene.add(debugBox);
                debugObjects.push(debugBox);
            }
        });

        // Add debug object for helicopter
        const helicopterDebugBox = new THREE.BoxHelper(helicopter, 0xff0000);
        helicopterDebugBox.visible = false;
        scene.add(helicopterDebugBox);
        debugObjects.push(helicopterDebugBox);

        // Collision system
        const collisionLog = [];
        let collisionCount = 0;

        // Helicopter explosion effect
        let isExploding = false;
        const explosionParticles = [];

        function createExplosion(position) {
            if (isExploding) return;
            if (typeof isShieldActive === 'function' && isShieldActive()) return; // ignore while shielded
            isExploding = true;
            helicopter.visible = false;
            document.getElementById('status').textContent = "Status: CRASHED!";
            document.getElementById('status').style.color = "#ff5555";

            const particleCount = 100;
            const colors = [0xFFA500, 0xFF4500, 0xFF6347, 0x808080, 0x333333];

            for (let i = 0; i < particleCount; i++) {
                const size = Math.random() * 0.5 + 0.2;
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const color = colors[Math.floor(Math.random() * colors.length)];
                const material = new THREE.MeshBasicMaterial({ color });

                const sphere = new THREE.Mesh(geometry, material);

                sphere.position.copy(position);
                sphere.position.x += (Math.random() - 0.5) * 5;
                sphere.position.y += (Math.random() - 0.5) * 5;
                sphere.position.z += (Math.random() - 0.5) * 5;

                scene.add(sphere);
                explosionParticles.push({
                    mesh: sphere,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() * 10) + 5,
                        (Math.random() - 0.5) * 10
                    ),
                    startTime: Date.now()
                });
            }

            setTimeout(resetHelicopter, 4000);
        }

        function resetHelicopter() {
            isExploding = false;

            explosionParticles.forEach(p => {
                scene.remove(p.mesh);
            });
            explosionParticles.length = 0;

            helicopterBody.position.set(0, 30, 0);
            helicopterBody.velocity.set(0, 0, 0);
            helicopterBody.angularVelocity.set(0, 0, 0);
            helicopterBody.quaternion.set(0, 0, 0, 1);
            helicopter.visible = true;
            document.getElementById('status').textContent = "Status: Flying";
            document.getElementById('status').style.color = "#c5e1a5";
        }

        // Orientation stabilization
        let stabilizationEnabled = true; // Always on
        
        function applyStabilization() {
            if (!stabilizationEnabled) return; // flag remains true
            
            // Get world up vector
            const worldUp = new CANNON.Vec3(0, 1, 0);
            
            // Get helicopter's current up vector in world space
            const currentUp = new CANNON.Vec3(0, 1, 0);
            helicopterBody.vectorToWorldFrame(currentUp, currentUp);
            
            // Calculate correction axis (cross product of currentUp and worldUp)
            const correctionAxis = new CANNON.Vec3();
            currentUp.cross(worldUp, correctionAxis);
            
            // Calculate the angle between the vectors (clamp dot to avoid NaN)
            const dotVal = Math.max(-1, Math.min(1, currentUp.dot(worldUp)));
            const angle = Math.acos(dotVal);
            
            // Only apply stabilization if there's a significant misalignment
            if (Math.abs(angle) > 0.05) {
                // Apply proportional torque to correct orientation
                const torqueStrength = 200;
                const torque = correctionAxis.scale(torqueStrength * angle);
                
                // Add damping to reduce oscillations
                const dampingStrength = 30;
                const dampingTorque = new CANNON.Vec3(
                    -helicopterBody.angularVelocity.x * dampingStrength,
                    -helicopterBody.angularVelocity.y * dampingStrength,
                    -helicopterBody.angularVelocity.z * dampingStrength
                );
                
                torque.vadd(dampingTorque, torque);
                // Cannon.js uses direct torque vector assignment
                helicopterBody.torque.vadd(torque, helicopterBody.torque);
            }
        }

        // Animation loop
        let rotorRotation = 0; // kept but not used for disk rotors
        const clock = new THREE.Clock();

        // Scoring
        let score = 0;
        let speedBoostExpirations = [];
        let currentPadIndex = -1;
        let scoredThisTouchdown = false;

        // Shield status
        let shieldExpirations = [];
        function isShieldActive() { return shieldExpirations.some(t => t > Date.now()); }

        function updatePowerupBanner() {
            const banner = document.getElementById('powerup-banner');
            if (!banner) return;
            const now = Date.now();
            const boosts = speedBoostExpirations.filter(t => t > now).length;
            const shields = shieldExpirations.filter(t => t > now).length;
            const parts = [];
            if (boosts > 0) parts.push(`Speed Boost x${boosts}`);
            if (shields > 0) parts.push(`Shield x${shields}`);
            banner.textContent = parts.join(' | ');
            if (parts.length) {
                banner.style.display = 'block';
                if (shields > 0) {
                    banner.style.boxShadow = '0 0 15px rgba(150, 100, 255, 0.6)';
                    banner.style.borderColor = 'rgba(170, 140, 255, 0.6)';
                } else {
                    banner.style.boxShadow = '0 0 15px rgba(255, 234, 0, 0.55)';
                    banner.style.borderColor = 'rgba(255, 234, 0, 0.45)';
                }
            } else {
                banner.style.display = 'none';
            }
        }

        // Timer and results
        const gameDurationMs = 3 * 60 * 1000; // 3 minutes
        let gameEndAt = Date.now() + gameDurationMs;
        let gameEnded = false;
        let totalHelipadPoints = 0;
        let totalHoopPoints = 0;
        let totalPointsAvailable = 0;

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            if (!isExploding) {
                const baseForceStrength = 50;
                const activeBoostsForForce = speedBoostExpirations.filter(t => t > Date.now()).length;
                const forceStrength = baseForceStrength * (activeBoostsForForce > 0 ? 4 * activeBoostsForForce : 1);
                const torqueStrength = 30;

                const force = new CANNON.Vec3(0, 0, 0);
                const torque = new CANNON.Vec3(0, 0, 0);

                force.y += 9.82 * helicopterBody.mass;

                const forward = new CANNON.Vec3();
                helicopterBody.quaternion.vmult(new CANNON.Vec3(1, 0, 0), forward);

                const right = new CANNON.Vec3();
                helicopterBody.quaternion.vmult(new CANNON.Vec3(0, 0, -1), right);

                if (keys.w) force.vadd(forward.scale(forceStrength), force);
                if (keys.s) force.vsub(forward.scale(forceStrength * 0.5), force);
                if (keys.up) force.y += forceStrength * 3; // Increased upward force
                if (keys.down) force.y -= forceStrength * 0.7;
                if (keys.left) force.vadd(right.scale(forceStrength * 0.6), force);
                if (keys.right) force.vsub(right.scale(forceStrength * 0.6), force);
                if (keys.a) torque.y += torqueStrength;
                if (keys.d) torque.y -= torqueStrength;

                helicopterBody.applyForce(force, helicopterBody.position);
                helicopterBody.torque.copy(torque);
                
                // Apply orientation stabilization
                applyStabilization();
            }

            world.step(1/60, deltaTime, 3);

            if (!isExploding) {
                helicopter.position.copy(helicopterBody.position);
                helicopter.quaternion.copy(helicopterBody.quaternion);

                // No rotor spin required with disk visuals
            }

            if (isExploding) {
                const now = Date.now();
                for (let i = explosionParticles.length - 1; i >= 0; i--) {
                    const p = explosionParticles[i];
                    const age = now - p.startTime;

                    p.velocity.y -= 0.1;

                    p.mesh.position.add(p.velocity.clone().multiplyScalar(deltaTime));

                    if (age > 2000) {
                        p.mesh.material.opacity = Math.max(0, 1 - (age - 2000) / 1000);
                        p.mesh.material.transparent = true;
                    }

                    if (age > 3000) {
                        scene.remove(p.mesh);
                        explosionParticles.splice(i, 1);
                    }
                }
            }

            // Birds update: wander and chase within 10 meters
            const chaseRadius = 10;
            const wanderSpeed = 4;
            const chaseSpeed = 9;
            for (let i = 0; i < birds.length; i++) {
                const b = birds[i];
                // Distance to helicopter
                const toHeli = new THREE.Vector3().copy(helicopter.position).sub(b.group.position);
                const dist = toHeli.length();
                b.chasing = dist < chaseRadius && !isExploding;

                if (b.chasing) {
                    // Accelerate towards helicopter
                    toHeli.normalize();
                    b.velocity.lerp(toHeli.multiplyScalar(chaseSpeed), 0.05);
                } else {
                    // Wander: small steering changes and altitude follow to stay above terrain
                    b.wanderPhase += deltaTime * 0.6;
                    const steer = new THREE.Vector3(Math.sin(b.wanderPhase), Math.sin(b.wanderPhase * 1.7) * 0.2, Math.cos(b.wanderPhase * 0.9));
                    b.velocity.add(steer.multiplyScalar(0.4 * deltaTime));
                    // Clamp speed
                    if (b.velocity.length() > wanderSpeed) b.velocity.setLength(wanderSpeed);
                    // Keep altitude above terrain + 8..18
                    const g = terrainHeight(b.group.position.x, b.group.position.z);
                    const targetY = Math.max(g + 8, water.position.y + 8) + (Math.sin(b.wanderPhase * 0.8) + 1) * 5;
                    const dy = targetY - b.group.position.y;
                    b.velocity.y += THREE.MathUtils.clamp(dy, -4, 4) * 0.5 * deltaTime;
                }

                // Integrate
                b.group.position.add(b.velocity.clone().multiplyScalar(deltaTime));
                // Face movement direction
                if (b.velocity.lengthSq() > 0.0001) {
                    const dir = b.velocity.clone().normalize();
                    const yaw = Math.atan2(dir.z, dir.x);
                    const pitch = Math.asin(THREE.MathUtils.clamp(dir.y, -0.99, 0.99));
                    b.group.rotation.set(0, 0, 0);
                    b.group.rotation.y = -yaw + Math.PI; // body points forward
                    b.group.rotation.x = -pitch;
                }

                // Wing flapping
                b.wingPhase += b.wingSpeed * deltaTime * (b.chasing ? 1.5 : 1.0);
                const flap = Math.sin(b.wingPhase) * 0.6 + (b.chasing ? 0.3 : 0);
                b.wingL.rotation.z = flap;
                b.wingR.rotation.z = -flap;

                // Keep within world bounds; wrap around softly
                const bound = terrainSize * 0.6;
                if (b.group.position.x > bound) b.group.position.x = -bound;
                if (b.group.position.x < -bound) b.group.position.x = bound;
                if (b.group.position.z > bound) b.group.position.z = -bound;
                if (b.group.position.z < -bound) b.group.position.z = bound;
            }

            const cameraOffset = new THREE.Vector3(-15, 8, 0);
            cameraOffset.applyQuaternion(helicopter.quaternion);
            camera.position.lerp(helicopter.position.clone().add(cameraOffset), 0.1);
            camera.lookAt(helicopter.position);

            // Expire speed boosts and update status
            const nowTs = Date.now();
            if (speedBoostExpirations.length || shieldExpirations.length) {
                speedBoostExpirations = speedBoostExpirations.filter(t => t > nowTs);
                shieldExpirations = shieldExpirations.filter(t => t > nowTs);
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    if (shieldExpirations.length > 0) { statusEl.textContent = 'Status: SHIELDED'; statusEl.style.color = '#b39ddb'; }
                    else if (speedBoostExpirations.length > 0) { statusEl.textContent = `Status: BOOST x${speedBoostExpirations.length}`; statusEl.style.color = '#ffe082'; }
                    else { statusEl.textContent = 'Status: Flying'; statusEl.style.color = '#c5e1a5'; }
                }
                updatePowerupBanner();
            }

            const speed = helicopterBody.velocity.length();
            const altitude = helicopterBody.position.y - terrainHeight(helicopterBody.position.x, helicopterBody.position.z);

            document.getElementById('speed-value').textContent = speed.toFixed(2);
            document.getElementById('altitude-value').textContent = `ALT: ${altitude.toFixed(1)}m`;
            document.getElementById('current-speed').textContent = `${speed.toFixed(2)} m/s`;
            document.getElementById('current-altitude').textContent = `${altitude.toFixed(1)} m`;

            const terrainHeightAtPos = groundYFormula(helicopterBody.position.x, helicopterBody.position.z);
            if (isFinite(terrainHeightAtPos) && helicopterBody.position.y < terrainHeightAtPos + 1.5) {
                const impactSpeedV = Math.abs(helicopterBody.velocity.y);
                const impactSpeedTotal = helicopterBody.velocity.length();
                if (impactSpeedV > 0.5 || impactSpeedTotal > 1.0) {
                    if (!isExploding && (impactSpeedV > 2.5 || impactSpeedTotal > 5.0)) {
                        createExplosion(helicopter.position.clone());
                    }
                }

                helicopterBody.position.y = terrainHeightAtPos + 1.5;
                helicopterBody.velocity.y *= -0.3;
            }

            // Timer UI
            if (!gameEnded) {
                const msLeft = Math.max(0, gameEndAt - Date.now());
                const secs = Math.ceil(msLeft / 1000);
                const mm = String(Math.floor(secs / 60)).padStart(2, '0');
                const ss = String(secs % 60).padStart(2, '0');
                const timerEl = document.getElementById('timer');
                if (timerEl) timerEl.textContent = `${mm}:${ss}`;
                if (msLeft === 0) gameEnded = true;
            }

            // Boost orb animations and pickup
            // Track cumulative time for orb bobbing
            const elapsedTime = clock.elapsedTime;
            for (let i = 0; i < boostOrbs.length; i++) {
                const orb = boostOrbs[i];
                if (orb.collected) continue;
                // Gentle bobbing
                orb.group.rotation.y += 0.01;
                orb.group.position.y = orb.baseY + Math.sin(elapsedTime * 1.5 + orb.phase) * 0.6;
                const dist = helicopterBody.position.distanceTo(orb.group.position);
                if (dist < 2.2) {
                    orb.collected = true;
                    scene.remove(orb.group);
                    speedBoostExpirations.push(Date.now() + 10000); // add 10s boost instance
                    updatePowerupBanner();
                }
            }

            // Shield orbs: bob, spin, and pickup
            for (let i = 0; i < shieldOrbs.length; i++) {
                const orb = shieldOrbs[i];
                if (orb.collected) continue;
                orb.group.rotation.y -= 0.01;
                orb.group.position.y = orb.baseY + Math.sin(elapsedTime * 1.2 + orb.phase) * 0.7;
                const dist = helicopterBody.position.distanceTo(orb.group.position);
                if (dist < 2.2) {
                    orb.collected = true;
                    scene.remove(orb.group);
                    shieldExpirations.push(Date.now() + 10000);
                    updatePowerupBanner();
                }
            }

            // Helipad landing detection
            let onPadIndex = -1;
            for (let i = 0; i < helipads.length; i++) {
                const pad = helipads[i];
                const dx = helicopterBody.position.x - pad.position.x;
                const dz = helicopterBody.position.z - pad.position.z;
                const horizontalDist = Math.hypot(dx, dz);
                const verticalDiff = Math.abs(helicopterBody.position.y - (pad.position.y + 1.5));
                const horizontalSpeed = Math.hypot(helicopterBody.velocity.x, helicopterBody.velocity.z);
                const verticalSpeed = Math.abs(helicopterBody.velocity.y);
                if (horizontalDist <= pad.radius && verticalDiff < 0.6 && horizontalSpeed < 1.2 && verticalSpeed < 0.6) {
                    onPadIndex = i;
                    break;
                }
            }

            if (onPadIndex !== -1) {
                if (currentPadIndex !== onPadIndex) {
                    currentPadIndex = onPadIndex;
                    scoredThisTouchdown = false;
                }
                const pad = helipads[onPadIndex];
                if (!scoredThisTouchdown && !pad.scored) {
                    score += 100;
                    pad.scored = true;
                    const sv = document.getElementById('score-value');
                    if (sv) sv.textContent = String(score);
                    scoredThisTouchdown = true;
                    // Remove visuals for collected helipad
                    if (pad.pad && pad.pad.parent) pad.pad.parent.remove(pad.pad);
                    if (pad.cross1 && pad.cross1.parent) pad.cross1.parent.remove(pad.cross1);
                    if (pad.cross2 && pad.cross2.parent) pad.cross2.parent.remove(pad.cross2);
                }
            } else {
                currentPadIndex = -1;
                scoredThisTouchdown = false;
            }

            // Hoop scoring (fly through center once)
            for (let i = 0; i < hoops.length; i++) {
                const hoop = hoops[i];
                if (hoop.scored) continue;
                // Distance to hoop center
                const dist = helicopterBody.position.distanceTo(hoop.position);
                // Consider a pass if within ring radius horizontally and reasonable altitude proximity
                if (dist < hoop.centerRadius * 0.8) {
                    hoop.scored = true;
                    score += 50;
                    const sv = document.getElementById('score-value');
                    if (sv) sv.textContent = String(score);
                    // Remove hoop visual once collected
                    if (hoop.mesh && hoop.mesh.parent) hoop.mesh.parent.remove(hoop.mesh);
                }
            }

            // Bird-helicopter collision
            if (!isExploding) {
                for (let i = 0; i < birds.length; i++) {
                    const b = birds[i];
                    const d = helicopterBody.position.distanceTo(b.group.position);
                    if (d < 1.6) {
                        createExplosion(helicopter.position.clone());
                        break;
                    }
                }
            }

            huts.forEach(hut => {
                const distance = helicopter.position.distanceTo(hut.position);
                if (distance < 8) {
                    const impactSpeed = helicopterBody.velocity.length();
                    if (impactSpeed > 2.5 && !isExploding) {
                        createExplosion(helicopter.position.clone());
                    }

                    const direction = helicopter.position.clone().sub(hut.position).normalize();
                    helicopterBody.velocity.add(new CANNON.Vec3(
                        direction.x * 5,
                        2,
                        direction.z * 5
                    ));
                }
            });

            clouds.forEach(cloud => {
                cloud.rotation.y += 0.001;
            });

            renderer.render(scene, camera);

            // End condition and result
            if (gameEnded) {
                const pointsAvailable = (helipads.length * 100) + (hoops.length * 50);
                const percent = (score / pointsAvailable) * 100;
                let title = 'You Lose';
                let color = '#ef5350';
                let desc = `You scored ${score} of ${pointsAvailable} points. Collect at least 50% to pass.`;
                if (percent > 90) { title = 'Excellent – You are a champion!'; color = '#ffeb3b'; desc = `Fantastic! ${Math.round(percent)}%`; }
                else if (percent > 75) { title = 'Great job!'; color = '#66bb6a'; desc = `Great job! ${Math.round(percent)}%`; }
                else if (percent >= 50) { title = 'Good job!'; color = '#42a5f5'; desc = `Good! ${Math.round(percent)}%`; }

                const overlay = document.getElementById('result-overlay');
                const titleEl = document.getElementById('result-title');
                const descEl = document.getElementById('result-desc');
                if (overlay && titleEl && descEl) {
                    titleEl.textContent = title;
                    titleEl.style.color = color;
                    descEl.textContent = desc;
                    overlay.style.display = 'flex';
                }
                return; // stop further updates after showing result
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (isSmallScreen()) { setupMobileControls(); }
        });

        animate();
    </script>
</body>
</html>