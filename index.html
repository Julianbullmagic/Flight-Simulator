<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable Helicopter Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #1a2980, #26d0ce);
            color: white;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        #title {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 22px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        .hut-info {
            font-size: 14px;
            margin-top: 10px;
            line-height: 1.5;
            color: #aaffaa;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #info-panel h2 {
            margin-top: 0;
            color: #4fc3f7;
            text-align: center;
            border-bottom: 1px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 10px;
        }
        .control-group {
            margin: 15px 0;
        }
        .control-label {
            display: inline-block;
            width: 140px;
            color: #bbbbff;
        }
        .control-value {
            color: #4fc3f7;
            font-weight: bold;
        }
        #debug-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
            transition: all 0.3s ease;
        }
        #debug-toggle:hover {
            background: rgba(30, 30, 60, 0.8);
            transform: scale(1.05);
        }
        #scoreboard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 18px;
            pointer-events: none;
            z-index: 14;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #collision-log {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 15px;
            max-height: 200px;
            overflow-y: auto;
            width: 300px;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #collision-log h3 {
            margin-top: 0;
            color: #4fc3f7;
            border-bottom: 1px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 8px;
        }
        .log-entry {
            margin: 8px 0;
            padding: 5px;
            border-radius: 4px;
            background: rgba(50, 50, 80, 0.4);
        }
        .warning {
            color: #ff9800;
        }
        .danger {
            color: #f44336;
            font-weight: bold;
        }
        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            width: 200px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        #speed-value {
            font-size: 32px;
            font-weight: bold;
            color: #4fc3f7;
            margin: 10px 0;
        }
        #altitude-value {
            font-size: 24px;
            color: #a5d6a7;
            margin: 5px 0;
        }
        #status {
            font-size: 18px;
            margin-top: 10px;
            color: #c5e1a5;
        }
        canvas {
            display: block;
        }
        /* Toolbar */
        #toolbar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 12px;
            border-radius: 12px;
            display: flex;
            gap: 8px;
            pointer-events: auto;
            z-index: 15;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.3);
        }
        .tool-btn {
            background: rgba(30, 30, 60, 0.8);
            color: #fff;
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        .tool-btn.active {
            background: rgba(0, 120, 200, 0.8);
        }
        /* Mobile controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: auto;
            z-index: 20;
        }
        .pad {
            width: 160px;
            height: 160px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
        }
        .pad-btn {
            background: rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            color: #ffffff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 12px rgba(0, 150, 255, 0.35);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .pad-btn:active {
            background: rgba(30, 30, 60, 0.8);
            transform: scale(0.98);
        }

        /* Responsive UI tweaks */
        @media (max-width: 900px) {
            #title { font-size: 18px; padding: 10px 16px; right: 12px; top: 12px; }
            #info-panel { max-width: 260px; padding: 14px; left: 12px; top: 64px; }
            #speedometer { width: 160px; padding: 14px; right: 12px; bottom: 12px; }
            #debug-toggle { left: 12px; bottom: 12px; padding: 10px 14px; }
            #collision-log { width: 240px; left: 12px; bottom: 70px; }
            #mobile-controls { display: flex; }
            .pad { width: 140px; height: 140px; }
            .pad-btn { font-size: 16px; }
            #toolbar { top: 12px; }
            /* Hide debug toggle on phone-sized screens */
            #debug-toggle { display: none; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui-container">
            <div id="scoreboard">Score: <span id="score-value">0</span></div>
            <div id="title">
                Stable Helicopter Simulator<br>
            </div>

            <div id="toolbar">
                <button class="tool-btn active" id="toggle-info">Info</button>
                <button class="tool-btn active" id="toggle-speed">Speedo</button>
                <button class="tool-btn active" id="toggle-log">Log</button>
            </div>

            <div id="info-panel">
                <h2>Flight Controls</h2>
                <div class="control-group">
                    <span class="control-label">W / S:</span>
                    <span class="control-value">Forward / Backward</span>
                </div>
                <div class="control-group">
                    <span class="control-label">Arrow Keys:</span>
                    <span class="control-value">Up/Down/Left/Right</span>
                </div>
                <div class="control-group">
                    <span class="control-label">A / D:</span>
                    <span class="control-value">Rotate Left/Right</span>
                </div>
                <div class="control-group">
                    <span class="control-label">R:</span>
                    <span class="control-value">Reset Helicopter</span>
                </div>
                <div class="control-group">
                    <span class="control-label">Current Speed:</span>
                    <span id="current-speed" class="control-value">0 m/s</span>
                </div>
                <div class="control-group">
                    <span class="control-label">Current Altitude:</span>
                    <span id="current-altitude" class="control-value">0 m</span>
                </div>
            </div>

            <div id="debug-toggle" onclick="toggleDebug()">TOGGLE DEBUG VIEW</div>

            <div id="speedometer">
                <div>SPEED</div>
                <div id="speed-value">0.00</div>
                <div>m/s</div>
                <div id="altitude-value">ALT: 0m</div>
                <div id="status">Status: Flying</div>
            </div>

            <div id="collision-log">
                <h3>Collision Log</h3>
                <div id="collision-entries"></div>
            </div>

            <!-- Mobile controls (shown on small screens) -->
            <div id="mobile-controls" aria-label="On-screen controls">
                <div class="pad" id="pad-left">
                    <div></div><button class="pad-btn" id="btn-l-up">↑</button><div></div>
                    <button class="pad-btn" id="btn-l-left">←</button><div></div><button class="pad-btn" id="btn-l-right">→</button>
                    <div></div><button class="pad-btn" id="btn-l-down">↓</button><div></div>
                </div>
                <div class="pad" id="pad-right">
                    <div></div><button class="pad-btn" id="btn-r-up">FWD</button><div></div>
                    <button class="pad-btn" id="btn-r-left">⟲</button><div></div><button class="pad-btn" id="btn-r-right">⟳</button>
                    <div></div><button class="pad-btn" id="btn-r-down">BACK</button><div></div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // Initialize Three.js and Cannon.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 30, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // Initialize physics world
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(100, 150, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Create skybox
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Create sun
        const sunGeometry = new THREE.SphereGeometry(15, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(150, 200, -100);
        scene.add(sun);

        // Terrain generation
        const terrainSize = 600;
        const terrainResolution = 80;
        const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainResolution - 1, terrainResolution - 1);

        // Height function for terrain
        function terrainHeight(x, y) {
            const scale = 0.03;
            return (
                Math.sin(x * scale) * Math.cos(y * scale) * 12 +
                Math.sin(x * scale * 3) * Math.cos(y * scale * 3) * 4 +
                Math.sin(x * scale * 6) * Math.cos(y * scale * 6) * 1.5
            );
        }

        // Apply terrain height
        const vertices = terrainGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const y = vertices[i + 1];
            vertices[i + 2] = terrainHeight(x, y);
        }
        terrainGeometry.attributes.position.needsUpdate = true;
        terrainGeometry.computeVertexNormals();

        const terrainMaterial = new THREE.MeshLambertMaterial({
            color: 0x32CD32,
            side: THREE.DoubleSide
        });

        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.receiveShadow = true;
        terrain.position.y = -2;
        scene.add(terrain);

        // Add physics terrain
        const heightfieldData = [];
        for (let i = 0; i < terrainResolution; i++) {
            heightfieldData.push([]);
            for (let j = 0; j < terrainResolution; j++) {
                const x = (j / (terrainResolution - 1) - 0.5) * terrainSize;
                const y = (i / (terrainResolution - 1) - 0.5) * terrainSize;
                heightfieldData[i].push(terrainHeight(x, y));
            }
        }

        const terrainShape = new CANNON.Heightfield(heightfieldData, {
            elementSize: terrainSize / (terrainResolution - 1)
        });

        const terrainBody = new CANNON.Body({ mass: 0 });
        terrainBody.addShape(terrainShape);
        terrainBody.position.set(-terrainSize/2, 0, terrainSize/2);
        terrainBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
        world.addBody(terrainBody);

        // Create a single large water plane
        const waterGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize);
        const waterMaterial = new THREE.MeshLambertMaterial({
            color: 0x1E90FF,
            transparent: true,
            opacity: 0.7
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -2.5; // Adjusted water level
        scene.add(water);

        // Create trees
        const trees = [];
        const treeCount = 1600;
        const treeMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });

        for (let i = 0; i < treeCount; i++) {
            const x = (Math.random() - 0.5) * terrainSize * 0.8;
            const z = (Math.random() - 0.5) * terrainSize * 0.8;
            const height = terrainHeight(x, z);

            if (height > water.position.y + 1) {
                const treeHeight = Math.random() * 8 + 6;
                const treeRadius = treeHeight / 5;

                const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 2, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, height-2, z);
                trunk.castShadow = true;
                scene.add(trunk);

                // Disable spherical-cluster canopy variant (always use cone)
                const useClusterCanopy = false;
                if (useClusterCanopy) {
                    const canopyGroup = new THREE.Group();
                    const leafColors = [
                        0x2e7d32, 0x388e3c, 0x43a047, 0x4caf50,
                        0x66bb6a, 0x1b5e20, 0x2e8b57
                    ];
                    const sphereCount = Math.floor(Math.random() * 5) + 6; // 6 - 10
                    const canopySpread = treeRadius * 0.9;
                    for (let j = 0; j < sphereCount; j++) {
                        const radius = Math.random() * (treeRadius * 0.35) + (treeRadius * 0.25);
                        const geo = new THREE.SphereGeometry(radius, 10, 10);
                        const color = leafColors[Math.floor(Math.random() * leafColors.length)];
                        const mat = new THREE.MeshLambertMaterial({ color });
                        const s = new THREE.Mesh(geo, mat);
                        const offsetX = (Math.random() - 0.5) * canopySpread;
                        const offsetZ = (Math.random() - 0.5) * canopySpread;
                        const offsetY = Math.random() * (treeHeight * 0.6);
                        s.position.set(offsetX, offsetY, offsetZ);
                        s.castShadow = true;
                        canopyGroup.add(s);
                    }
                    canopyGroup.position.set(x, height - 1 + treeHeight * 0.35, z);
                    scene.add(canopyGroup);
                    trees.push({ trunk, canopy: canopyGroup, position: new THREE.Vector3(x, height, z) });
                } else {
                    const canopyGeometry = new THREE.ConeGeometry(treeRadius, treeHeight, 8);
                    const canopy = new THREE.Mesh(canopyGeometry, treeMaterial);
                    canopy.position.set(x, height -1 + treeHeight/2, z);
                    canopy.castShadow = true;
                    scene.add(canopy);
                    trees.push({ trunk, canopy, position: new THREE.Vector3(x, height, z) });
                }
            }
        }

        // Create bushes
        const bushes = [];
        const bushCount = 1800;
        const bushColors = [0x32CD32, 0x228B22, 0x3CB371, 0x2E8B57, 0x008000];

        for (let i = 0; i < bushCount; i++) {
            const x = (Math.random() - 0.5) * terrainSize * 0.8;
            const z = (Math.random() - 0.5) * terrainSize * 0.8;
            const height = terrainHeight(x, z);

            if (height > water.position.y + 1.5) {
                const bushGroup = new THREE.Group();
                const bushSize = Math.random() * 4 + 3;

                const sphereCount = Math.floor(Math.random() * 4) + 3;
                for (let j = 0; j < sphereCount; j++) {
                    const radius = Math.random() * 0.8 + 0.6;
                    const color = bushColors[Math.floor(Math.random() * bushColors.length)];
                    const sphereGeometry = new THREE.SphereGeometry(radius, 8, 8);
                    const sphereMaterial = new THREE.MeshLambertMaterial({ color });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

                    const offsetX = (Math.random() - 0.5) * bushSize;
                    const offsetZ = (Math.random() - 0.5) * bushSize;
                    const offsetY = Math.random() * 1.5;

                    sphere.position.set(offsetX, offsetY, offsetZ);
                    sphere.castShadow = true;
                    bushGroup.add(sphere);
                }

                // Position the bush group so its base is at terrain height
                bushGroup.position.set(x, height-2, z);
                scene.add(bushGroup);
                bushes.push(bushGroup);
            }
        }

        // Create wooden huts with improved placement
        const huts = [];
        const hutPositions = [
            {x: 40, z: 30}, {x: -35, z: 45}, {x: 25, z: -50},
            {x: -50, z: -25}, {x: 60, z: -30}, {x: -20, z: 70},
            {x: 45, z: 55}, {x: -70, z: 20}, {x: 10, z: -60},
            {x: -30, z: 20}, {x: 20, z: 40}, {x: -40, z: -40}
        ];

        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.lineWidth = 2;

            for (let i = 0; i < 80; i++) {
                const x1 = Math.random() * canvas.width;
                const y1 = Math.random() * canvas.height;
                const x2 = x1 + (Math.random() - 0.5) * 80;
                const y2 = y1 + (Math.random() - 0.5) * 80;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.bezierCurveTo(
                    x1 + (Math.random() - 0.5) * 60, y1 + (Math.random() - 0.5) * 60,
                    x2 + (Math.random() - 0.5) * 60, y2 + (Math.random() - 0.5) * 60,
                    x2, y2
                );
                ctx.stroke();
            }
            return canvas;
        }

        const woodTexture = new THREE.CanvasTexture(createWoodTexture());
        const darkWoodTexture = new THREE.CanvasTexture(createWoodTexture());

        hutPositions.forEach(pos => {
            // Calculate average height for the hut footprint
            let heightSum = 0;
            let samplePoints = 0;
            
            // Sample multiple points within the hut area
            for (let dx = -1; dx <= 1; dx += 1) {
                for (let dz = -1; dz <= 1; dz += 1) {
                    const sampleX = pos.x + dx * 3;
                    const sampleZ = pos.z + dz * 3;
                    heightSum += terrainHeight(sampleX, sampleZ);
                    samplePoints++;
                }
            }
            
            const avgHeight = heightSum / samplePoints;

            if (avgHeight > water.position.y + 2) {
                const hutWidth = 6 + Math.random() * 4;
                const hutHeight = 4 + Math.random() * 2;
                const hutDepth = 6 + Math.random() * 4;

                const hutGeometry = new THREE.BoxGeometry(hutWidth, hutHeight, hutDepth);
                const hutMaterial = new THREE.MeshLambertMaterial({ map: woodTexture });
                const hut = new THREE.Mesh(hutGeometry, hutMaterial);
                hut.position.set(pos.x, avgHeight, pos.z);
                hut.castShadow = true;
                scene.add(hut);

                const roofHeight = hutHeight * 1;
                const roofGeometry = new THREE.ConeGeometry(hutWidth, roofHeight, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ map: darkWoodTexture });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(pos.x, avgHeight + hutHeight, pos.z);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                scene.add(roof);

                const doorWidth = hutWidth * 0.3;
                const doorHeight = hutHeight * 0.7;
                const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.15);
                const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x5D2906 });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(pos.x, avgHeight, pos.z + hutDepth/2 + 0.05);
                scene.add(door);

                const windowSize = Math.min(hutWidth, hutHeight) * 0.25;
                const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.15);
                const windowMaterial = new THREE.MeshLambertMaterial({
                    color: 0xADD8E6,
                    transparent: true,
                    opacity: 0.6
                });
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(
                    pos.x - hutWidth/4,
                    avgHeight,
                    pos.z + hutDepth/2 + 0.05
                );
                scene.add(window);

                huts.push({ hut, roof, door, window, position: new THREE.Vector3(pos.x, avgHeight, pos.z) });
            }
        });

        // Create helicopter
        const helicopter = new THREE.Group();

        const bodyGeometry = new THREE.CylinderGeometry(1.2, 1.2, 5, 16);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0x4169E1,
            shininess: 80
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.z = Math.PI / 2;
        body.castShadow = true;
        helicopter.add(body);

        const tailGeometry = new THREE.CylinderGeometry(0.25, 0.4, 4, 10);
        const tailMaterial = new THREE.MeshPhongMaterial({
            color: 0x5577EE,
            shininess: 60
        });
        const tail = new THREE.Mesh(tailGeometry, tailMaterial);
        tail.position.set(-3.5, 0.4, 0);
        tail.rotation.z = Math.PI / 2;
        tail.castShadow = true;
        helicopter.add(tail);

        // Translucent rotor disks
        const mainRotor = new THREE.Mesh(
            new THREE.CircleGeometry(5.5, 48),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.22, side: THREE.DoubleSide })
        );
        mainRotor.rotation.x = -Math.PI / 2; // horizontal (XZ plane)
        mainRotor.position.set(0, 2.5, 0);
        helicopter.add(mainRotor);

        const tailRotor = new THREE.Mesh(
            new THREE.CircleGeometry(2.2, 40),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.22, side: THREE.DoubleSide })
        );
        tailRotor.position.set(-5, 0.4, 0);
        // Make disk face sideways: plane = YZ, so normal = ±X
        tailRotor.rotation.set(0, -Math.PI / 2, 0);
        helicopter.add(tailRotor);

        const skidGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4, 8);
        const skidMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });

        const leftSkid = new THREE.Mesh(skidGeometry, skidMaterial);
        leftSkid.position.set(0, -1.5, -1.5);
        helicopter.add(leftSkid);

        const rightSkid = new THREE.Mesh(skidGeometry, skidMaterial);
        rightSkid.position.set(0, -1.5, 1.5);
        helicopter.add(rightSkid);

        const frontSkidGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
        const frontSkid = new THREE.Mesh(frontSkidGeometry, skidMaterial);
        frontSkid.position.set(1.5, -1.5, 0);
        frontSkid.rotation.z = Math.PI / 2;
        helicopter.add(frontSkid);

        const backSkid = new THREE.Mesh(frontSkidGeometry, skidMaterial);
        backSkid.position.set(-1.5, -1.5, 0);
        backSkid.rotation.z = Math.PI / 2;
        helicopter.add(backSkid);

        helicopter.position.set(0, 30, 0);
        scene.add(helicopter);

        // Create helipads with red crosses
        const helipads = [];
        const helipadCount = 5;
        const helipadColors = [0x4fc3f7, 0xffcc80, 0xa5d6a7, 0xffab91, 0xce93d8];
        for (let i = 0; i < helipadCount; i++) {
            let x, z, y;
            let tries = 0;
            do {
                x = (Math.random() - 0.5) * terrainSize * 0.7;
                z = (Math.random() - 0.5) * terrainSize * 0.7;
                y = terrainHeight(x, z);
                tries++;
            } while ((y <= water.position.y + 2) && tries < 50);

            const padRadius = 4;
            const padHeight = 0.2;
            const pad = new THREE.Mesh(
                new THREE.CylinderGeometry(padRadius, padRadius, padHeight, 32),
                new THREE.MeshLambertMaterial({ color: helipadColors[i % helipadColors.length] })
            );
            pad.receiveShadow = true;
            pad.position.set(x, y - padHeight/2, z);
            scene.add(pad);

            const crossThickness = 0.4;
            const crossLength = padRadius * 1.8;
            const crossMat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
            const cross1 = new THREE.Mesh(new THREE.BoxGeometry(crossLength, crossThickness, crossThickness), crossMat);
            const cross2 = new THREE.Mesh(new THREE.BoxGeometry(crossThickness, crossThickness, crossLength), crossMat);
            cross1.position.set(x, y + crossThickness/2 + 0.02, z);
            cross2.position.set(x, y + crossThickness/2 + 0.02, z);
            cross1.castShadow = true; cross2.castShadow = true;
            scene.add(cross1); scene.add(cross2);

            helipads.push({ position: new THREE.Vector3(x, y, z), radius: padRadius, scored: false });
        }

        // Create colored hoops to fly through
        const hoops = [];
        const hoopCount = 8;
        const hoopColors = [0xff7043, 0x42a5f5, 0x66bb6a, 0xffca28, 0xab47bc, 0x26a69a, 0xef5350, 0x8d6e63];
        for (let i = 0; i < hoopCount; i++) {
            const ringRadius = 3.5; // major radius
            const tubeRadius = 0.35; // thickness of ring
            const torus = new THREE.Mesh(
                new THREE.TorusGeometry(ringRadius, tubeRadius, 12, 48),
                new THREE.MeshLambertMaterial({ color: hoopColors[i % hoopColors.length] })
            );

            const hx = (Math.random() - 0.5) * terrainSize * 0.6;
            const hz = (Math.random() - 0.5) * terrainSize * 0.6;
            const hy = Math.max(terrainHeight(hx, hz) + 4, water.position.y + 4) + Math.random() * 16;

            torus.position.set(hx, hy, hz);
            torus.rotation.y = Math.random() * Math.PI * 2; // face random direction
            torus.castShadow = true;
            scene.add(torus);

            hoops.push({ mesh: torus, position: new THREE.Vector3(hx, hy, hz), centerRadius: ringRadius, scored: false });
        }

        // Add physics body for helicopter
        const helicopterShape = new CANNON.Box(new CANNON.Vec3(2, 1.2, 1));
        const helicopterBody = new CANNON.Body({
            mass: 5,
            linearDamping: 0.5,
            angularDamping: 0.8
        });
        helicopterBody.addShape(helicopterShape);
        helicopterBody.position.copy(helicopter.position);
        world.addBody(helicopterBody);

        // Add clouds
        const clouds = [];
        const cloudGeometry = new THREE.SphereGeometry(16, 24, 24);
        const cloudMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.5,
            shininess: 10
        });

        for (let i = 0; i < 20; i++) {
            const cloudGroup = new THREE.Group();
            const cloudCount = Math.floor(Math.random() * 4) + 3;

            for (let j = 0; j < cloudCount; j++) {
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                
                cloud.position.set(
                    (Math.random() - 0.5) * 24,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 24
                );
                cloud.scale.set(
                    Math.random() + 1,
                    Math.random() * 0.5 + 0.5,
                    Math.random() + 1
                );
                cloudGroup.add(cloud);
            }

            cloudGroup.position.set(
                (Math.random() - 0.5) * 800,
                100 + Math.random() * 100,
                (Math.random() - 0.5) * 800
            );
            scene.add(cloudGroup);
            clouds.push(cloudGroup);
        }

        // Flight controls
        const keys = { w: false, s: false, a: false, d: false, up: false, down: false, left: false, right: false };
        document.addEventListener('keydown', (event) => {
            switch(event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyD': keys.d = true; break;
                case 'ArrowUp': keys.up = true; break;
                case 'ArrowDown': keys.down = true; break;
                case 'ArrowLeft': keys.left = true; break;
                case 'ArrowRight': keys.right = true; break;
                case 'KeyR': resetHelicopter(); break;
            }
        });
        document.addEventListener('keyup', (event) => {
            switch(event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyD': keys.d = false; break;
                case 'ArrowUp': keys.up = false; break;
                case 'ArrowDown': keys.down = false; break;
                case 'ArrowLeft': keys.left = false; break;
                case 'ArrowRight': keys.right = false; break;
            }
        });

        // Mobile/touch controls
        // Detect small screens for mobile control enablement
        function isSmallScreen() { return window.innerWidth <= 900; }

        function bindButtonToKey(buttonId, keyName) {
            const el = document.getElementById(buttonId);
            if (!el) return;

            const press = (e) => { e.preventDefault(); keys[keyName] = true; };
            const release = (e) => { e.preventDefault(); keys[keyName] = false; };

            el.addEventListener('pointerdown', press);
            el.addEventListener('pointerup', release);
            el.addEventListener('pointerleave', release);
            el.addEventListener('pointercancel', release);
            el.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        let mobileControlsInitialized = false;

        function setupMobileControls() {
            const controls = document.getElementById('mobile-controls');
            if (!controls) return;
            if (mobileControlsInitialized) return;

            // Left pad: Arrow keys (strafe and altitude)
            bindButtonToKey('btn-l-up', 'up');
            bindButtonToKey('btn-l-down', 'down');
            bindButtonToKey('btn-l-left', 'left');
            bindButtonToKey('btn-l-right', 'right');

            // Right pad: Forward/Back and Yaw
            bindButtonToKey('btn-r-up', 'w');
            bindButtonToKey('btn-r-down', 's');
            bindButtonToKey('btn-r-left', 'a');
            bindButtonToKey('btn-r-right', 'd');

            mobileControlsInitialized = true;
        }

        if (isSmallScreen()) { setupMobileControls(); }

        // Panel toggles
        function setupPanelToggles() {
            const infoPanel = document.getElementById('info-panel');
            const speedometer = document.getElementById('speedometer');
            const collisionLogPanel = document.getElementById('collision-log');
            const btnInfo = document.getElementById('toggle-info');
            const btnSpeed = document.getElementById('toggle-speed');
            const btnLog = document.getElementById('toggle-log');

            function toggle(el, btn) {
                if (!el) return;
                const nowVisible = el.style.display !== 'none';
                el.style.display = nowVisible ? 'none' : '';
                btn.classList.toggle('active', !nowVisible);
            }

            btnInfo.addEventListener('click', () => toggle(infoPanel, btnInfo));
            btnSpeed.addEventListener('click', () => toggle(speedometer, btnSpeed));
            btnLog.addEventListener('click', () => toggle(collisionLogPanel, btnLog));

            // On small screens, hide info panel and log by default to reduce overlap
            if (window.innerWidth <= 900) {
                infoPanel.style.display = 'none';
                btnInfo.classList.remove('active');
                if (collisionLogPanel) collisionLogPanel.style.display = 'none';
                btnLog.classList.remove('active');
            }
        }
        setupPanelToggles();

        // Debug mode toggle
        let debugMode = false;
        const debugObjects = [];

        function toggleDebug() {
            debugMode = !debugMode;
            debugObjects.forEach(obj => { obj.visible = debugMode; });
            document.getElementById('debug-toggle').textContent = debugMode ?
                'DEBUG VIEW: ON' : 'DEBUG VIEW: OFF';
            document.getElementById('debug-toggle').style.background = debugMode ?
                'rgba(200, 50, 50, 0.8)' : 'rgba(0, 0, 0, 0.7)';
        }

        // Add debug objects for huts
        hutPositions.forEach(pos => {
            const height = terrainHeight(pos.x, pos.z);
            if (height > water.position.y + 1) {
                const debugBox = new THREE.BoxHelper(new THREE.Mesh(
                    new THREE.BoxGeometry(6, 4, 6)
                ), 0xffff00);
                debugBox.position.set(pos.x, height + 2, pos.z);
                debugBox.visible = false;
                scene.add(debugBox);
                debugObjects.push(debugBox);
            }
        });

        // Add debug object for helicopter
        const helicopterDebugBox = new THREE.BoxHelper(helicopter, 0xff0000);
        helicopterDebugBox.visible = false;
        scene.add(helicopterDebugBox);
        debugObjects.push(helicopterDebugBox);

        // Collision system
        const collisionLog = [];
        let collisionCount = 0;

        // Helicopter explosion effect
        let isExploding = false;
        const explosionParticles = [];

        function createExplosion(position) {
            if (isExploding) return;
            isExploding = true;
            helicopter.visible = false;
            document.getElementById('status').textContent = "Status: CRASHED!";
            document.getElementById('status').style.color = "#ff5555";

            const particleCount = 100;
            const colors = [0xFFA500, 0xFF4500, 0xFF6347, 0x808080, 0x333333];

            for (let i = 0; i < particleCount; i++) {
                const size = Math.random() * 0.5 + 0.2;
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const color = colors[Math.floor(Math.random() * colors.length)];
                const material = new THREE.MeshBasicMaterial({ color });

                const sphere = new THREE.Mesh(geometry, material);

                sphere.position.copy(position);
                sphere.position.x += (Math.random() - 0.5) * 5;
                sphere.position.y += (Math.random() - 0.5) * 5;
                sphere.position.z += (Math.random() - 0.5) * 5;

                scene.add(sphere);
                explosionParticles.push({
                    mesh: sphere,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() * 10) + 5,
                        (Math.random() - 0.5) * 10
                    ),
                    startTime: Date.now()
                });
            }

            setTimeout(resetHelicopter, 4000);
        }

        function resetHelicopter() {
            isExploding = false;

            explosionParticles.forEach(p => {
                scene.remove(p.mesh);
            });
            explosionParticles.length = 0;

            helicopterBody.position.set(0, 30, 0);
            helicopterBody.velocity.set(0, 0, 0);
            helicopterBody.angularVelocity.set(0, 0, 0);
            helicopterBody.quaternion.set(0, 0, 0, 1);
            helicopter.visible = true;
            document.getElementById('status').textContent = "Status: Flying";
            document.getElementById('status').style.color = "#c5e1a5";
        }

        // Orientation stabilization
        let stabilizationEnabled = true; // Always on
        
        function applyStabilization() {
            if (!stabilizationEnabled) return; // flag remains true
            
            // Get world up vector
            const worldUp = new CANNON.Vec3(0, 1, 0);
            
            // Get helicopter's current up vector in world space
            const currentUp = new CANNON.Vec3(0, 1, 0);
            helicopterBody.vectorToWorldFrame(currentUp, currentUp);
            
            // Calculate correction axis (cross product of currentUp and worldUp)
            const correctionAxis = new CANNON.Vec3();
            currentUp.cross(worldUp, correctionAxis);
            
            // Calculate the angle between the vectors (clamp dot to avoid NaN)
            const dotVal = Math.max(-1, Math.min(1, currentUp.dot(worldUp)));
            const angle = Math.acos(dotVal);
            
            // Only apply stabilization if there's a significant misalignment
            if (Math.abs(angle) > 0.05) {
                // Apply proportional torque to correct orientation
                const torqueStrength = 200;
                const torque = correctionAxis.scale(torqueStrength * angle);
                
                // Add damping to reduce oscillations
                const dampingStrength = 30;
                const dampingTorque = new CANNON.Vec3(
                    -helicopterBody.angularVelocity.x * dampingStrength,
                    -helicopterBody.angularVelocity.y * dampingStrength,
                    -helicopterBody.angularVelocity.z * dampingStrength
                );
                
                torque.vadd(dampingTorque, torque);
                // Cannon.js uses direct torque vector assignment
                helicopterBody.torque.vadd(torque, helicopterBody.torque);
            }
        }

        // Animation loop
        let rotorRotation = 0; // kept but not used for disk rotors
        const clock = new THREE.Clock();

        // Scoring
        let score = 0;
        let currentPadIndex = -1;
        let scoredThisTouchdown = false;

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            if (!isExploding) {
                const forceStrength = 50;
                const torqueStrength = 30;

                const force = new CANNON.Vec3(0, 0, 0);
                const torque = new CANNON.Vec3(0, 0, 0);

                force.y += 9.82 * helicopterBody.mass;

                const forward = new CANNON.Vec3();
                helicopterBody.quaternion.vmult(new CANNON.Vec3(1, 0, 0), forward);

                const right = new CANNON.Vec3();
                helicopterBody.quaternion.vmult(new CANNON.Vec3(0, 0, -1), right);

                if (keys.w) force.vadd(forward.scale(forceStrength), force);
                if (keys.s) force.vsub(forward.scale(forceStrength * 0.5), force);
                if (keys.up) force.y += forceStrength * 3; // Increased upward force
                if (keys.down) force.y -= forceStrength * 0.7;
                if (keys.left) force.vadd(right.scale(forceStrength * 0.6), force);
                if (keys.right) force.vsub(right.scale(forceStrength * 0.6), force);
                if (keys.a) torque.y += torqueStrength;
                if (keys.d) torque.y -= torqueStrength;

                helicopterBody.applyForce(force, helicopterBody.position);
                helicopterBody.torque.copy(torque);
                
                // Apply orientation stabilization
                applyStabilization();
            }

            world.step(1/60, deltaTime, 3);

            if (!isExploding) {
                helicopter.position.copy(helicopterBody.position);
                helicopter.quaternion.copy(helicopterBody.quaternion);

                // No rotor spin required with disk visuals
            }

            if (isExploding) {
                const now = Date.now();
                for (let i = explosionParticles.length - 1; i >= 0; i--) {
                    const p = explosionParticles[i];
                    const age = now - p.startTime;

                    p.velocity.y -= 0.1;

                    p.mesh.position.add(p.velocity.clone().multiplyScalar(deltaTime));

                    if (age > 2000) {
                        p.mesh.material.opacity = Math.max(0, 1 - (age - 2000) / 1000);
                        p.mesh.material.transparent = true;
                    }

                    if (age > 3000) {
                        scene.remove(p.mesh);
                        explosionParticles.splice(i, 1);
                    }
                }
            }

            const cameraOffset = new THREE.Vector3(-15, 8, 0);
            cameraOffset.applyQuaternion(helicopter.quaternion);
            camera.position.lerp(helicopter.position.clone().add(cameraOffset), 0.1);
            camera.lookAt(helicopter.position);

            const speed = helicopterBody.velocity.length();
            const altitude = helicopterBody.position.y - terrainHeight(helicopterBody.position.x, helicopterBody.position.z);

            document.getElementById('speed-value').textContent = speed.toFixed(2);
            document.getElementById('altitude-value').textContent = `ALT: ${altitude.toFixed(1)}m`;
            document.getElementById('current-speed').textContent = `${speed.toFixed(2)} m/s`;
            document.getElementById('current-altitude').textContent = `${altitude.toFixed(1)} m`;

            const terrainHeightAtPos = terrainHeight(helicopterBody.position.x, helicopterBody.position.z);
            if (isFinite(terrainHeightAtPos) && helicopterBody.position.y < terrainHeightAtPos + 1.5) {
                const impactSpeedV = Math.abs(helicopterBody.velocity.y);
                const impactSpeedTotal = helicopterBody.velocity.length();
                if (impactSpeedV > 0.5 || impactSpeedTotal > 1.0) {
                    if (!isExploding && (impactSpeedV > 2.5 || impactSpeedTotal > 5.0)) {
                        createExplosion(helicopter.position.clone());
                    }
                }

                helicopterBody.position.y = terrainHeightAtPos + 1.5;
                helicopterBody.velocity.y *= -0.3;
            }

            // Helipad landing detection
            let onPadIndex = -1;
            for (let i = 0; i < helipads.length; i++) {
                const pad = helipads[i];
                const dx = helicopterBody.position.x - pad.position.x;
                const dz = helicopterBody.position.z - pad.position.z;
                const horizontalDist = Math.hypot(dx, dz);
                const verticalDiff = Math.abs(helicopterBody.position.y - (pad.position.y + 1.5));
                const horizontalSpeed = Math.hypot(helicopterBody.velocity.x, helicopterBody.velocity.z);
                const verticalSpeed = Math.abs(helicopterBody.velocity.y);
                if (horizontalDist <= pad.radius && verticalDiff < 0.6 && horizontalSpeed < 1.2 && verticalSpeed < 0.6) {
                    onPadIndex = i;
                    break;
                }
            }

            if (onPadIndex !== -1) {
                if (currentPadIndex !== onPadIndex) {
                    currentPadIndex = onPadIndex;
                    scoredThisTouchdown = false;
                }
                const pad = helipads[onPadIndex];
                if (!scoredThisTouchdown && !pad.scored) {
                    score += 100;
                    pad.scored = true;
                    const sv = document.getElementById('score-value');
                    if (sv) sv.textContent = String(score);
                    scoredThisTouchdown = true;
                }
            } else {
                currentPadIndex = -1;
                scoredThisTouchdown = false;
            }

            // Hoop scoring (fly through center once)
            for (let i = 0; i < hoops.length; i++) {
                const hoop = hoops[i];
                if (hoop.scored) continue;
                // Distance to hoop center
                const dist = helicopterBody.position.distanceTo(hoop.position);
                // Consider a pass if within ring radius horizontally and reasonable altitude proximity
                if (dist < hoop.centerRadius * 0.8) {
                    hoop.scored = true;
                    score += 50;
                    const sv = document.getElementById('score-value');
                    if (sv) sv.textContent = String(score);
                }
            }

            huts.forEach(hut => {
                const distance = helicopter.position.distanceTo(hut.position);
                if (distance < 8) {
                    const impactSpeed = helicopterBody.velocity.length();
                    if (impactSpeed > 2.5 && !isExploding) {
                        createExplosion(helicopter.position.clone());
                    }

                    const direction = helicopter.position.clone().sub(hut.position).normalize();
                    helicopterBody.velocity.add(new CANNON.Vec3(
                        direction.x * 5,
                        2,
                        direction.z * 5
                    ));
                }
            });

            clouds.forEach(cloud => {
                cloud.rotation.y += 0.001;
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (isSmallScreen()) { setupMobileControls(); }
        });

        animate();
    </script>
</body>
</html>